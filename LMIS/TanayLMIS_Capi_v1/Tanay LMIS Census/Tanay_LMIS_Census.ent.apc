{Application 'TANAY_LMIS_CENSUS' logic file generated by CSPro}
PROC GLOBAL

array string labels(99);
array codes(99);
//---set dynamic value for Geocode


PROC HH_NUMBER_OF_HOUSEHOLD_MEMBER
	
preproc 
		// Set number of household members to size of person roster. 
		// It is used as roster occurrence control field for later rosters. 
		HH_NUMBER_OF_HOUSEHOLD_MEMBER = totocc(HOUSEHOLD_MEMBERS_ROSTER); 
PROC HH_START_INTERVIEW_TIME

PROC TANAYLMIS_CAPI_FF

PROC HH_REGION
	
PROC HH_PROVINCE

onfocus

// Build dynamic value set for selected REGION based on PROVINCE in lookup file
numeric nextEntry = 0;

// Start with the first PROVINCE in the REGION (PROVINCE 1)
GEO_REGION = HH_REGION;
GEO_PROVINCE = 1;
GEO_MUNICIPAL = notappl;
GEO_BARANGAY = notappl;
GEO_EA = notappl;

// Loop through all PROVINCE in selected REGION starting with PROVINCE 1
// The call to locate finds the next case whose ids match or are greater than the desired PROVINCE. If the PROVINCES are
// numbered sequentially with no gaps then this will be an exact match but if there are gaps then it will skip
// over them.
while locate(GEOCODE_DICT, >=, maketext("%02d%02d%02d%03d%03d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_EA)) and loadcase(GEOCODE_DICT) do

	if GEO_REGION <> HH_REGION then
		// The next case is in a different REGION so there are no more PROVINCE in this REGION
		// and we are done.
		break;
	endif;
	
	// If the structure of the lookup file is correct, we should be on a case for a PROVINCE meaning that
	// the PROVINCE is not blank, the MUNICIPAL, BARANGAY and EA are blank.
	if GEO_PROVINCE <> notappl and GEO_MUNICIPAL = notappl and GEO_BARANGAY = notappl and GEO_EA = notappl then
		// Add the PROVINCE to the value set
		labels(nextEntry) = GEO_AREA_NAME;
		codes(nextEntry) = GEO_PROVINCE;
		nextEntry = nextEntry + 1;
	else
		errmsg("Geo code lookup has invalid structure on line: reg=%02d prov=%02d mun=%02d bgy=%03d ea=%3d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_EA);
		exit;
	endif;
	
	// Find the next PROVINCE
	GEO_PROVINCE = GEO_PROVINCE + 1;
enddo;

// Add terminator to value set
codes(nextEntry) = notappl;

setvalueset(HH_PROVINCE, codes, labels);

PROC HH_MUNICIPAL

onfocus

// Build dynamic value set for selected REGION and PROVINCE based on MUNICIPALS in lookup file
numeric nextEntry = 0;

// Start with the first MUNICIPAL in the PROVINCE in the REGION (MUNICIPAL 1)
GEO_REGION = HH_REGION;
GEO_PROVINCE = HH_PROVINCE;
GEO_MUNICIPAL = 1;
GEO_BARANGAY = notappl;
GEO_EA = notappl;

// Loop through all MUNICIPALS in selected PROVINCE in the selected REGION starting with MUNICIPAL 1
// The call to locate finds the next case whose ids match or are greater than the desired MUNICIPAL. If the districts are
// numbered sequentially with no gaps then this will be an exact match but if there are gaps then it will skip
// over them.
while locate(GEOCODE_DICT, >=, maketext("%02d%02d%02d%03d%03d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_EA)) and loadcase(GEOCODE_DICT) do

	if GEO_REGION <> HH_REGION or GEO_PROVINCE <> HH_PROVINCE then
		// The next case is in a different REGION or in a different PROVINCE so there are no more MUNICIPALS in this PROVINCE or in this REGION
		// and we are done.
		break;
	endif;
	
	// If the structure of the lookup file is correct, we should be on a case for a MUNICIPAL meaning that
	// the REGION and PROVINCE are not blank and the village is blank.
	if GEO_PROVINCE <> notappl and GEO_MUNICIPAL <> notappl and GEO_BARANGAY = notappl and GEO_EA = notappl then
		// Add the district to the value set
		labels(nextEntry) = GEO_AREA_NAME;
		codes(nextEntry) = GEO_MUNICIPAL;
		nextEntry = nextEntry + 1;
	else
		errmsg("Geo code lookup has invalid structure on line: reg=%02d prov=%02d mun=%02d bgy=%03d ea=%3d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_EA);
		exit;
	endif;
	
	// Find the next district
	GEO_MUNICIPAL = GEO_MUNICIPAL + 1;
enddo;

// Add terminator to value set
codes(nextEntry) = notappl;

setvalueset(HH_MUNICIPAL, codes, labels);

PROC HH_BARANGAY

onfocus

// Build dynamic value set for selected REGION and PROVINCE and MUNICIPAL based on BARANGAYS in lookup file
numeric nextEntry = 0;

// Start with the first BARANGAY in the MUNICIPAL in the PROVINCE in the REGION (BARANGAY 1)
GEO_REGION = HH_REGION;
GEO_PROVINCE = HH_PROVINCE;
GEO_MUNICIPAL = HH_MUNICIPAL;
GEO_BARANGAY = 1;
GEO_EA = notappl;

// Loop through all BARANGAYS in selected MUNICIPAL in the PROVINCE in the selected REGION starting with BARANGAY 1
// The call to locate finds the next case whose ids match or are greater than the desired MUNICIPAL. If the districts are
// numbered sequentially with no gaps then this will be an exact match but if there are gaps then it will skip
// over them.
while locate(GEOCODE_DICT, >=, maketext("%02d%02d%02d%03d%03d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_EA)) and loadcase(GEOCODE_DICT) do

	if GEO_REGION <> HH_REGION or GEO_PROVINCE <> HH_PROVINCE or GEO_MUNICIPAL <> HH_MUNICIPAL then
		// The next case is in a different REGION or in a different PROVINCE so there are no more MUNICIPALS in this PROVINCE or in this REGION
		// and we are done.
		break;
	endif;
	
	// If the structure of the lookup file is correct, we should be on a case for a MUNICIPAL meaning that
	// the REGION and PROVINCE are not blank and the village is blank.
	if GEO_PROVINCE <> notappl and GEO_MUNICIPAL <> notappl and GEO_BARANGAY <> notappl and GEO_EA = notappl then
		// Add the district to the value set
		labels(nextEntry) = GEO_AREA_NAME;
		codes(nextEntry) = GEO_BARANGAY;
		nextEntry = nextEntry + 1;
	else
		errmsg("Geo code lookup has invalid structure on line: reg=%02d prov=%02d mun=%02d bgy=%03d ea=%3d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_EA);
		exit;
	endif;
	
	// Find the next district
	GEO_BARANGAY = GEO_BARANGAY + 1;
enddo;

// Add terminator to value set
codes(nextEntry) = notappl;

setvalueset(HH_BARANGAY, codes, labels);


PROC HH_EA

onfocus

// Build dynamic value set for selected REGION and PROVINCE and MUNICIPAL based on BARANGAYS in lookup file
numeric nextEntry = 0;

// Start with the first BARANGAY in the MUNICIPAL in the PROVINCE in the REGION (BARANGAY 1)
GEO_REGION = HH_REGION;
GEO_PROVINCE = HH_PROVINCE;
GEO_MUNICIPAL = HH_MUNICIPAL;
GEO_BARANGAY = HH_BARANGAY;
GEO_EA = 1;

// Loop through all BARANGAYS in selected MUNICIPAL in the PROVINCE in the selected REGION starting with BARANGAY 1
// The call to locate finds the next case whose ids match or are greater than the desired MUNICIPAL. If the districts are
// numbered sequentially with no gaps then this will be an exact match but if there are gaps then it will skip
// over them.
while locate(GEOCODE_DICT, >=, maketext("%02d%02d%02d%03d%03d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_EA)) and loadcase(GEOCODE_DICT) do

	if GEO_REGION <> HH_REGION or GEO_PROVINCE <> HH_PROVINCE or GEO_MUNICIPAL <> HH_MUNICIPAL or GEO_BARANGAY <> HH_BARANGAY then
		// The next case is in a different REGION or in a different PROVINCE so there are no more MUNICIPALS in this PROVINCE or in this REGION
		// and we are done.
		break;
	endif;
	
	// If the structure of the lookup file is correct, we should be on a case for a MUNICIPAL meaning that
	// the REGION and PROVINCE are not blank and the village is blank.
	if GEO_PROVINCE <> notappl and GEO_MUNICIPAL <> notappl and GEO_BARANGAY <> notappl and GEO_EA <> notappl then
		// Add the district to the value set
		labels(nextEntry) = GEO_AREA_NAME;
		codes(nextEntry) = GEO_EA;
		nextEntry = nextEntry + 1;
	else
		errmsg("Geo code lookup has invalid structure on line: reg=%02d prov=%02d mun=%02d bgy=%03d ea=%3d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_EA);
		exit;
	endif;
	
	// Find the next district
	GEO_EA = GEO_EA + 1;
enddo;

// Add terminator to value set
codes(nextEntry) = notappl;

setvalueset(HH_EA, codes, labels);




PROC HOUSEHOLD_MEMBERS_ROSTER
	// After demographics roster is complete, check to make sure that there is 
	// exactly one head of household. 
	numeric numberOfHeads = count(DEMOGRAPHIC_RECORD where HH_RELATIONSHIP = 1); 
		if numberOfHeads <> 1 then    
			errmsg("Number of heads of household must be exactly one");    
			reenter HH_RELATIONSHIP(1); 
		endif; 

PROC HH_FIRSTNAME
	if curocc() = 1 then    
	// Set label for case in case listing to an easier to read format.    
	// We do this when we first get the name of the head.    
		string caseLabel = maketext("%03d%05d: %s",
	        HH_BARANGAY, HH_NUMBER, strip(HH_FIRSTNAME));
		setcaselabel(TANAYLMIS_CAPI_DICT, caseLabel); 
	endif;

	setocclabel(HOUSEHOLD_MEMBERS_ROSTER(curocc()), strip(HH_FIRSTNAME));
PROC HH_SEX

PROC HH_RELATIONSHIP
	
onfocus 
	// Show male or female version of value set depending on sex of the person. 
	if HH_SEX = 1 then
	    setvalueset(HH_RELATIONSHIP, HH_RELATIONSHIP_MALE); 
	else
	    setvalueset(HH_RELATIONSHIP, HH_RELATIONSHIP_FEMALE); 
	endif; 
	
postproc	
	// Don't allow non-head of household on first row 
	if HH_RELATIONSHIP <> 1 and curocc() = 1 then    
		errmsg("Please enter the head of household before the other household members.");    
		reenter; 
	endif; 
	// Don't allow head of household on a row other than first row 
	if HH_RELATIONSHIP = 1 and curocc() <> 1 then    
		errmsg("Only one head of household is allowed. Head of household was already entered.");    
		reenter; 
	endif; 
	//Household should not be less than 15 years old
	if HH_AGE > 15 and HH_RELATIONSHIP = 1 then
		errmsg("Head of the household is less than 15 years old");
		reenter;
	endif;	
	
		
PROC HH_AGE
	
preproc
		//Calculate age
		numeric monthBorn = (HH_INTERVIEW_MONTH-HH_MONTH_BORN);
			if monthBorn>=0 then
				$=(HH_INTERVIEW_YEAR-HH_YEAR_BORN);
			else
				$=(HH_INTERVIEW_YEAR-HH_YEAR_BORN-1);
			endif;

PROC HH_MORE_ROWS
// Exit roster when no more people in household 
	if $ = 2 then
	    endgroup; 
	endif; 

PROC DEMOGRAPHIC_ROSTER

PROC HH_PLACE_OF_BIRTH
	if $=1 then 
		skip to HH_NATIONALITY;
	endif;

PROC HH_NATIONALITY
	if $=1 then 
		skip to HH_CIVIL_STATUS;
	endif;

PROC HH_CIVIL_STATUS
	if $ in 1,3,4 and HH_RELATIONSHIP = 2 then
		errmsg("%s has a relationship spouse and civil status of %s.  Spouse cannot be single, widowed or separated",
			strip (HH_FIRSTNAME), getlabel(HH_CIVIL_STATUS, HH_CIVIL_STATUS));
		reenter;
	endif;
	
	if HH_AGE < 18 and $ in 2:4 then
		errmsg("Too young to get married");
		reenter;
	endif;

PROC HH_HIGHEST_EDUCATION_COMPL
	if HH_AGE>=5 then
		skip to HH_CURRENTLY_ENROLLED
	endif;

PROC HH_CURRENTLY_ENROLLED
	
preproc
		ask if HH_AGE<3 and HH_AGE>24;
	
postproc
		if HH_CURRENTLY_ENROLLED = 3 then
			skip to HH_WORKING;
		endif;
	
PROC HH_PROVINCE_ENROLLE
	
preproc
		if HH_CURRENTLY_ENROLLED = notappl then
			skip to HH_WORKING;
		endif;

PROC HH_MUNICIPALITY_ENROLLED

PROC HH_WORKING
	
preproc
		if HH_AGE in 0:15 then 
		 	skip to HH_HEALTH_INSURANCE;
		endif;
	
postproc
		if $=1 then
			skip to HH_OCCUPATION;
		endif;
		
PROC HH_REASON_OF_NOT_WORKING

preproc
		ask if HH_WORKING=2;

	
PROC HH_OCCUPATION
	
preproc
		if HH_WORKING=2 then
			skip to HH_PLACE_OF_BIRTH_DELIVERY;
		endif;
	

PROC HH_PROVINCE_OF_WORK

PROC HH_MUNICIPAL_OF_WORK

PROC HH_OCCUPATION_STATUS


PROC HH_MONTHLY_INCOME

PROC HH_PLACE_OF_BIRTH_DELIVERY
	
preproc 
		if HH_AGE>1 then
			skip to HH_NUMBER_OF_CHILDREN;
		endif;
	
postproc
		if $ in 1:4 then
			skip to HH_BIRTH_ATTENDANT;
		endif;

PROC HH_BIRTH_ATTENDANT
	if $ in 1:4 then
		skip to HH_IMMUNIZATION;
	endif;

PROC HH_NUMBER_OF_CHILDREN
	
preproc
		if HH_AGE in 15:49 and HH_SEX=1 then
			skip to HH_HEALTH_INSURANCE;
		endif; 

PROC HH_LIVING_CHILDREN
	
preproc
		if HH_NUMBER_OF_CHILDREN = 0 then
			skip to HH_FAMILY_PLANNING_METHOD_USED;
		endif;

PROC HH_FAMILY_PLANNING_METHOD_USED
	if $ = 10 then
		skip to HH_INTENT_TO_USE_FP;
	endif;

PROC HH_SOURCE_OF_FP_METHOD
	if $ in 1:5 then
		skip to HH_HEALTH_INSURANCE;
	endif;

PROC HH_OTHER_SOURCE_OF_FP_METHOD

PROC HH_INTENT_TO_USE_FP
	
preproc
		ask if HH_FAMILY_PLANNING_METHOD_USED = 10;
	
postproc
		if $=2 then
			skip to HH_REASON_OF_NO_INTENT_TO_USE_FP;
		endif;

PROC HH_PF_METHOD_INTENT_TO_USE

PROC HH_REASON_OF_NO_INTENT_TO_USE_FP
	
preproc 
		ask if HH_INTENT_TO_USE_FP = 2;

PROC HH_HEALTH_INSURANCE
	if $ in 1:7 then 
		skip to HH_HEALTH_FACILITY_VISITED;
	endif;

PROC HH_HEALTH_FACILITY_VISITED
	if $ in 1:7 then 
		skip to HH_REASON_FOR_VISIT;
	endif;

PROC HH_REASON_FOR_VISIT
	if $ in 1:7 then 
		skip to HH_DISABILITY;
	endif;

PROC HH_DISABILITY
	if $=2 then 
		skip to HH_SOLO_PARENT;
	endif;

PROC HH_SOLO_PARENT
	
preproc
		ask if HH_AGE>=15;

PROC HH_REGISTERED_SENIOR_CITIZEN
	
preproc
		ask if HH_AGE>=60;

PROC HH_REGISTERED_VOTER
	
preproc
		ask if HH_AGE>=18;
	
postproc
		if $=2 then
			skip to HH_MONTH_NUMBER_STAY;
		endif;

PROC HH_TYPE_OF_RESIDENT
	
preproc
		numeric number_month = HH_INTERVIEW_MONTH - HH_MONTH_BORN;
		numeric number_year_in_months = (HH_INTERVIEW_YEAR - HH_YEAR_BORN)*12;
		numeric year_stay_in_months = HH_YEAR_NUMBER_STAY*12;
			if	(number_month + number_year_in_months) - (year_stay_in_months +	HH_MONTH_NUMBER_STAY) = 0 then
				$ = 1;
				skip to next;
			elseif (number_month + number_year_in_months) - (year_stay_in_months +	HH_MONTH_NUMBER_STAY) >= 6 then
				$ = 2;
			elseif (number_month + number_year_in_months) - (year_stay_in_months +	HH_MONTH_NUMBER_STAY) < 6 then
				$ = 3;
				skip to HH_MUNICIPAL_RESIDENCE_6MO_AGO;
			endif;
 
PROC HH_MUNICIPAL_RESIDENCE_5Y_AGO
	
preproc
		ask if HH_AGE >= 5 and HH_TYPE_OF_RESIDENT = 2;

PROC HH_BARANGAY_RESIDENCE_5Y_AGO
	skip to HH_MONTH_TRANSFERRED;

PROC HH_MUNICIPAL_RESIDENCE_6MO_AGO
	
preproc
		ask if HH_AGE < 6;

PROC HH_BARANGAY_RESIDENCE_6MO_AGO

PROC HH_MONTH_TRANSFERRED

PROC HH_YEAR_TRANSFERRED

PROC HH_OTHER_REASON_OR_LEAVING
	
preproc
		ask if pos("7",HH_REASON_FOR_LEAVING) = 0;

PROC HH_OTHER_REASON_FOR_TRANSFERRING
	
preproc
		ask if pos("5",HH_REASON_FOR_TRANSFERRING) = 0;

PROC HH_SKILLS_DEVELOPMENT_TRAINING
	skip to next;

PROC HH_FUEL_LIGHTING


PROC HH_OTHER_FUEL_FOR_LIGHTING
	
preproc
		ask if HH_FUEL_LIGHTING = 5;
		
PROC HH_OTHER_FUEL_FOR_COOKING
	
preproc
		ask if HH_FUEL_COOKING = 6;
		
PROC HH_OTHER_SOURCE_DRINKING_WATER
	
preproc
		ask if HH_DRINKING_WATER = 12;
		
PROC HH_OTHER_TOILER_FACILITY
	
preproc
		ask if HH_TOILET_FACILITY = 7;
		
PROC HH_OTHER_OUTER_WALL
	
preproc
		ask if HH_OUTER_WALL = 9;
PROC HH_NUMBER_OF_FEMALE_DEATH
	
PROC HH_FEMALE_DEATH_ROSTER
	
preproc
		ask if HH_NUMBER_OF_FEMALE_DEATH > 0;
PROC HH_CHILD_DEATH_BELOW5_ROSTER
	
preproc
		ask if HH_NUMBER_OF_CHILD > 0;
